#Copyright (C) 2013 by Ngan Nguyen
#
#Released under the MIT license, see LICENSE.txt

'''Compare models among non-productive vs productive, among 
different samples, different groups etc
Get the median model
'''

import os
import sys
import numbers
import cPickle as pickle
import gzip
import numpy as np

from jobTree.scriptTree.target import Target
from sonLib.bioio import system

import aimseqtk.lib.common as lcommon
import aimseqtk.lib.drawcommon as drawcommon
from aimseqtk.src.recomb.recomb_model import RecombModel


def union_models(models):
    # for each attribute, find the union list of keys and add the
    # missing keys of to each sample (with val = 0)
    if not models:
        return
    for attr in models[0].get_attrs_depth1():
        key_lists = [m[attr].keys() for m in models]
        union_keys = lcommon.union_lists(key_lists)
        for k in union_keys:
            for m in models:
                if k not in m[attr]:
                    m[attr][k] = 0.0
    for attr in models[0].get_attrs_depth2():
        key_lists = [m[attr].keys() for m in models]
        union_keys = lcommon.union_lists(key_lists)
        for k in union_keys:
            for m in models:
                if k not in m[attr]:
                    m[attr][k] = {}
        for k in union_keys:
            key_lists2 = [m[attr][k].keys() for m in models]
            union_keys2 = lcommon.union_lists(key_lists2)
            for k2 in union_keys2:
                for m in models:
                    if k2 not in m[attr][k]:
                        m[attr][k][k2] = 0.0

def model_get_median(models):
    # note: has to do "union_models" before this
    if not models:
        return None
    elif len(models) == 1:
        return models[0]

    med_model = RecombModel()
    for attr in med_model.get_attrs_depth1():
        for k in models[0][attr].keys():
            vec = [m[attr][k] for m in models]
            med_model[attr][k] = np.median(vec)

    for attr in med_model.get_attrs_depth2():
        for k, mydict in models[0][attr].iteritems():
            med_model[attr][k] = {}
            for k2 in mydict.keys():
                vec = [m[attr][k][k2] for m in models]
                med_model[attr][k][k2] = np.median(vec)

    return med_model

def diff_sample_model(in_model, models, attr):
    # compare model generated by each sample with the input "standard"
    # model
    assert attr in in_model.get_attrs_depth1()
    k2diffs = {}
    for k, v in in_model[attr].iteritems():
        k2diffs[k] = [m[attr][k] - v for m in models]
    return k2diffs

def diff_sample_model2(in_model, models, attr):
    # compare model generated by each sample with the input "standard"
    # model
    assert attr in in_model.get_attrs_depth2()
    k_to_k2diffs = {}
    for k, k2v in in_model[attr].iteritems():
        k2diffs = {}
        for k2, v in k2v.iteritems():
            k2diffs[k2] = [m[attr][k][k2] - v for m in models]
        k_to_k2diffs[k] = k2diffs
    return k_to_k2diffs

def diff_plot(x2yvec, outbase, xlabels=[], label=''):
    if not x2yvec:
        return
    axes, fig, pdf = drawcommon.get_axes(outfile=outbase)
    if not xlabels:
        xlabels = sorted(x2yvec.keys())
    xdata = range(len(xlabels))
    ydata = [x2yvec[x] for x in xlabels]
    axes.boxplot(ydata)
    drawcommon.set_grid(axes)
    drawcommon.edit_spine(axes)
    if (isinstance(xlabels[0], numbers.Number) or
        isinstance(xlabels[0], tuple)):
        xlabels = [str(x) for x in xlabels]
    xlabels = [x.lstrip("TRB") for x in xlabels]
    drawcommon.set_xticks(axes, [x + 1 for x in xdata], xlabels)
    axes.set_xlim(-0.5, len(xlabels) + 0.5)
    #axes.set_ylim(bottom=-0.005)
    drawcommon.adjust_ticklabels(axes, xrotation=75)
    drawcommon.set_labels(axes, xlabel=label,
                          ylabel="Difference in %s" % label)
    drawcommon.write_image(fig, pdf, 'pdf', outbase, 300) 
    
def model_diff(indir1, indir2, outdir):
    # indir1 contains sam1_model.pickle, sam2_model.pickle ...
    # indir2: similarly to indir1
    name1 = os.path.basename(indir1.rstrip("/"))
    name2 = os.path.basename(indir2.rstrip("/"))
    objs1 = lcommon.load_pickledir(indir1)
    objs2 = lcommon.load_pickledir(indir2)
    union_models(objs1 + objs2)
    
    med1 = model_get_median(objs1)
    #med2 = model_get_median(objs2)
    for attr in med1.get_attrs_depth1():
        outbase1 = os.path.join(outdir, "%s_%s_cmp2_%s" % (attr, name2, name1))
        k2diffs1 = diff_sample_model(med1, objs2, attr)
        diff_plot(k2diffs1, outbase1)
        #outbase2 = os.path.join(outdir, "%s_%s_cmp2_%s" % (attr, name1, name2))
        #k2diffs2 = diff_sample_model(med2, objs1, attr)
        #diff_plot(k2diffs2, outbase2)
    for attr in med1.get_attrs_depth2():
        k_k2diffs1 = diff_sample_model2(med1, objs2, attr)
        for k, k2diffs1 in k_k2diffs1.iteritems():
            if not isinstance(k, str):
                k = str(k)
            outbase1 = os.path.join(outdir, "%s_%s_%s_cmp2_%s" % (attr, k, name2, name1))
            diff_plot(k2diffs1, outbase1)
        #k_k2diffs2 = diff_sample_model2(med2, objs1, attr)
        #for k, k2diffs2 in k_k2diffs2.iteritems():
        #    if not isinstance(k, str):
        #        k = str(k)
        #    outbase2 = os.path.join(outdir, "%s_%s_%s_cmp2_%s" % (attr, k, name1, name2))
        #    diff_plot(k2diffs2, outbase2)
    
    
def main():
    indir1 = sys.argv[1]
    indir2 = sys.argv[2]
    outdir = sys.argv[3]
    model_diff(indir1, indir2, outdir)

if __name__ == '__main__':
    main()





